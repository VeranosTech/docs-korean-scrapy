# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2016, Scrapy developers
# This file is distributed under the same license as the Scrapy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Scrapy 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-13 13:17+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../docs/topics/items.rst:5
msgid "Items"
msgstr "아이템"

#: ../docs/topics/items.rst:10
msgid ""
"The main goal in scraping is to extract structured data from unstructured"
" sources, typically, web pages. Scrapy spiders can return the extracted "
"data as Python dicts. While convenient and familiar, Python dicts lack "
"structure: it is easy to make a typo in a field name or return "
"inconsistent data, especially in a larger project with many spiders."
msgstr ""
"스크랩핑의 주 목적은 구조화되지 않은 자료, 주로 웹페이지에서 구조화된 자료를 추출하는 것이다. 스크래피(Scrapy) "
"스파이더(spider)는 추출된 데이터를 파이썬(Python) 딕셔너리로 반환할 수 있다. 이는 편리하고 친숙하지만, 파이썬 "
"딕셔너리는 구조가 부족하다: 특히 많은 스파이더를 사용하는 거대한 프로젝트에서는 필드 이름에 오타를 내거나 일관성 없는 데이터를 "
"반환하기 쉽다."

#: ../docs/topics/items.rst:16
msgid ""
"To define common output data format Scrapy provides the :class:`Item` "
"class. :class:`Item` objects are simple containers used to collect the "
"scraped data. They provide a `dictionary-like`_ API with a convenient "
"syntax for declaring their available fields."
msgstr ""
"공통적인 출력 데이터 포맷을 정의하기 위해서 스크래피는 :class:`Item` 클래스를 제공한다. :class:`Item` 객체는"
" 스크랩된 데이터를 모으기 위한 간단한 컨테이너다. 이 객체는 `딕셔너리 형`_ API에 사용할 수 있는 필드를 편리하게 선언할 수"
" 있는 신택스(syntax)를 제공한다."

#: ../docs/topics/items.rst:21
msgid ""
"Various Scrapy components use extra information provided by Items: "
"exporters look at declared fields to figure out columns to export, "
"serialization can be customized using Item fields metadata, "
":mod:`trackref` tracks Item instances to help find memory leaks (see :ref"
":`topics-leaks-trackrefs`), etc."
msgstr ""
"다양한 스크래피 구성요소는 아이템이 제공하는 추가적인 정보를 사용한다: 익스포터(exporter)sms 내보낼 컬럼(column)을"
" 알아내기 위해 선언된 필드를 확인하며, 직렬화(serialization)는 아이템 필드의 메타데이터를 사용해 커스터마이즈할 수 "
"있고, :mod:`trackref`\\ 는 메모리 누수를 감지를 돕기 위해 아이템 인스턴스를 추척한다 (:ref:`topics-"
"leaks-trackrefs`\\ 를 참고하라)."

#: ../docs/topics/items.rst:32
msgid "Declaring Items"
msgstr "아이템 선언"

#: ../docs/topics/items.rst:34
msgid ""
"Items are declared using a simple class definition syntax and "
":class:`Field` objects. Here is an example::"
msgstr "아이템은 간단한 클래스 정의 신택스와 :class:`Field` 객체를 사용해 선언된다. 다음은 선언의 예시이다::"

#: ../docs/topics/items.rst:45
msgid ""
"Those familiar with `Django`_ will notice that Scrapy Items are declared "
"similar to `Django Models`_, except that Scrapy Items are much simpler as"
" there is no concept of different field types."
msgstr ""
"`장고(Django)`_\\ 와 익숙한 사람은 스크래피 아이템이 다른 필드 타입이 없기 때문에 훨씬 단순하다는 사실을 제외하면 "
"`장고 모델`_\\ 과 유사하게 선언되는 것을 알아차렸을 것이다."

#: ../docs/topics/items.rst:55
msgid "Item Fields"
msgstr "아이템 필드"

#: ../docs/topics/items.rst:57
msgid ""
":class:`Field` objects are used to specify metadata for each field. For "
"example, the serializer function for the ``last_updated`` field "
"illustrated in the example above."
msgstr ""
":class:`Field` 객체는 각 필드의 메타데이터를 지정하기 위해 사용된다. 위의 예시에서 묘사된 "
"``last_updated`` 필드를 위한 직렬화 함수가 그 예이다."

#: ../docs/topics/items.rst:61
msgid ""
"You can specify any kind of metadata for each field. There is no "
"restriction on the values accepted by :class:`Field` objects. For this "
"same reason, there is no reference list of all available metadata keys. "
"Each key defined in :class:`Field` objects could be used by a different "
"component, and only those components know about it. You can also define "
"and use any other :class:`Field` key in your project too, for your own "
"needs. The main goal of :class:`Field` objects is to provide a way to "
"define all field metadata in one place. Typically, those components whose"
" behaviour depends on each field use certain field keys to configure that"
" behaviour. You must refer to their documentation to see which metadata "
"keys are used by each component."
msgstr ""
"사용자는 각 필드에 대한 모든 종류의 메타데이터를 지정할 수 있다.\\ :class:`Field` 객체가 받아들이는 값에 대해 "
"제한은 없다. 같은 이유 때문에, 사용 가능한 메타데이터 키의 참조 리스트는 없다. :class:`Field` 객체에서 정의된 각 "
"키는 다른 구성요소에서 사용될 수 있고, 구성요소만이 그것에 대해 알고 있다. 또한 필요에 맞게 프로젝트에 다른 "
":class:`Field`\\ 를 정의하고 사용할 수 있다. :class:`Field`\\ 객체의 주 목표는 한 장소에 모든 필드 "
"메타데이터를 정의하는 방법을 제공하는 것이다. 일반적으로 동작이 각 필드에 의존하는 구성요소는 그 동작을 구성하는 특정 필드 키를 "
"사용한다. 어떤 메타데이터 키가 각 구성요소에 사용되는지를 보려면 해당 문서를 반드시 참고해야 한다."

#: ../docs/topics/items.rst:72
msgid ""
"It's important to note that the :class:`Field` objects used to declare "
"the item do not stay assigned as class attributes. Instead, they can be "
"accessed through the :attr:`Item.fields` attribute."
msgstr ""
"아이템을 선언하기 위해 사용된 :class:`Field` 객체는 클래스 속성으로 할당된 채 남아있지 않는다는 사실을 명심하라. "
"대신, :attr:`Item.fields` 속성을 통해서 접근할 수 있다."

#: ../docs/topics/items.rst:77
msgid "Working with Items"
msgstr "아이템으로 작업하기"

#: ../docs/topics/items.rst:79
msgid ""
"Here are some examples of common tasks performed with items, using the "
"``Product`` item :ref:`declared above  <topics-items-declaring>`. You "
"will notice the API is very similar to the `dict API`_."
msgstr ""
"이 섹션에는 :ref:`위에서 선언된 <topics-items-declaring>` ``Product`` 아이템을 사용해서 수행하는"
" 일반적인 작업의 예시가 있다. API가 `딕셔너리 API`_\\ 와 매우 유사하다는 사실을 알게 될 것이다."

#: ../docs/topics/items.rst:84
msgid "Creating items"
msgstr "아이템 생성"

#: ../docs/topics/items.rst:93
msgid "Getting field values"
msgstr "필드 값 얻기"

#: ../docs/topics/items.rst:134
msgid "Setting field values"
msgstr "필드 값 설정"

#: ../docs/topics/items.rst:148
msgid "Accessing all populated values"
msgstr "Accessing all populated values"

#: ../docs/topics/items.rst:150
msgid "To access all populated values, just use the typical `dict API`_::"
msgstr "입력된 모든 값에 접근하려면, 일반적인 `딕셔너리 API`_\\ 를 사용하라::"

#: ../docs/topics/items.rst:159
msgid "Other common tasks"
msgstr "다른 일반 작업"

#: ../docs/topics/items.rst:161
msgid "Copying items::"
msgstr "아이템 복사::"


#: ../docs/topics/items.rst:171
msgid "Creating dicts from items::"
msgstr "아이템으로 딕셔너리 생성::"

#: ../docs/topics/items.rst:176
msgid "Creating items from dicts::"
msgstr "딕셔너리로 아이템 생성::"


#: ../docs/topics/items.rst:187
msgid "Extending Items"
msgstr "아이템 확장하기"

#: ../docs/topics/items.rst:189
msgid ""
"You can extend Items (to add more fields or to change some metadata for "
"some fields) by declaring a subclass of your original Item."
msgstr "원본 아이템의 상속클래스를 선언해서 아이템을 확장(필드를 추가하거나 필드의 메타데이터를 변경)할 수 있다."

#: ../docs/topics/items.rst:192
msgid "For example::"
msgstr "예::"

#: ../docs/topics/items.rst:198
msgid ""
"You can also extend field metadata by using the previous field metadata "
"and appending more values, or changing existing values, like this::"
msgstr "또한 이전 필드의 메타데이터를 사용해서 값을 더 추가하거나 기존의 값을 변경시켜서 필드 메타데이터를 확장할 수 있다::::"

#: ../docs/topics/items.rst:204
msgid ""
"That adds (or replaces) the ``serializer`` metadata key for the ``name`` "
"field, keeping all the previously existing metadata values."
msgstr ""
"위 코드는 ``name`` 필드를 위한 ``serializeer`` 메타데이터 키를 추가 (또는 교체) 시키면서 기존의 메타데이터 "
"값은 유지시켰다."

#: ../docs/topics/items.rst:208
msgid "Item objects"
msgstr "아이템 객체"

#: ../docs/topics/items.rst:212
msgid "Return a new Item optionally initialized from the given argument."
msgstr "주어진 인자로 선택적으로 초기화된 새로운 아이템을 반환한다."

#: ../docs/topics/items.rst:214
msgid ""
"Items replicate the standard `dict API`_, including its constructor. The "
"only additional attribute provided by Items is:"
msgstr ""
"아이템은 생성자(constructor)를 포함해, 기본 `딕셔너리 API`_\\ 를 복제했다. 아이템으로 제공되는 유일한 추가 "
"속성은 아래와 같다:"

#: ../docs/topics/items.rst:219
msgid ""
"A dictionary containing *all declared fields* for this Item, not only "
"those populated. The keys are the field names and the values are the "
":class:`Field` objects used in the :ref:`Item declaration <topics-items-"
"declaring>`."
msgstr ""
"이 아이템에 입력된 것뿐만 아니라 *선언된 모든 필드*\\ 를 포함하는 사전. 키는 필드 이름이고 값은 :ref:`아이템 선언 "
"<topics-items-declaring>` 내에서 사용되는 :class:`Field` 객체다."

#: ../docs/topics/items.rst:227
msgid "Field objects"
msgstr "필드 객체"

#: ../docs/topics/items.rst:231
msgid ""
"The :class:`Field` class is just an alias to the built-in `dict`_ class "
"and doesn't provide any extra functionality or attributes. In other "
"words, :class:`Field` objects are plain-old Python dicts. A separate "
"class is used to support the :ref:`item declaration syntax <topics-items-"
"declaring>` based on class attributes."
msgstr ""
":class:`Field` 클래스는 단순히 내장 `딕셔너리`_ 클래스에 대한 알리아스(alilas)이며 추가적인 기능이나 속성을 "
"제공하지 않는다. 즉, :class:`Field` 객체는 평범한 파이썬 딕셔너리다. 별도의 클래스는 클래스 속성을 기반으로 하는 "
":ref:`아이템 선언 신택스 <topics-items-declaring>`\\ 를 지원하는 데 사용된다"
